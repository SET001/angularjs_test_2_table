// Generated by CoffeeScript 1.6.3
(function() {
  angular.module('mwTable', ['ngCookies']).factory('Table', [
    '$cookieStore', '$filter', '$rootScope', '$log', function($cookieStore, $filter, $rootScope, $log) {
      return function(config) {
        var self;
        self = $rootScope.$new();
        self.config = {
          name: null,
          type: null,
          getter: null,
          filters: {
            all: {}
          },
          params: {},
          sortingClasses: {
            asc: '',
            desc: '',
            none: ''
          },
          do_filter: function(data) {
            return data.slice(0);
          }
        };
        self.params = {
          limit: 20,
          page: 1,
          filter: 'all',
          search: '',
          orderby: '',
          reverse: false
        };
        self.data = {
          display: [],
          total: 0,
          pages: 0,
          first: 0,
          last: 0,
          paginaion: []
        };
        angular.extend(self.config, config);
        if (!self.config.name) {
          $log.warn("Table name is not properly set for module mwTable. Table will not work.");
          return self;
        }
        if (['full', 'partial'].indexOf(self.config.type) === -1) {
          $log.warn("Table type is not properly set for module mwTable. Must be either 'full' or 'partial'. Table will not work.");
          return self;
        }
        if (typeof self.config.getter !== 'function') {
          $log.warn("Table getter is not properly set for module mwTable. Must be a function. Table will not work.");
          return self;
        }
        angular.extend(self.params, self.config.params);
        self.initialized = false;
        self.raw = [];
        self.$watch('raw', function() {
          return self.operate();
        });
        self.$watch('params', (function(oldObj, newObj) {
          var data, forceReload;
          if (angular.equals(oldObj, newObj) && self.initialized) {
            return;
          }
          forceReload = false;
          if (self.params.random != null) {
            delete self.params.random;
            forceReload = true;
          }
          $cookieStore.put("tables." + self.config.name, self.params);
          if (self.config.type === 'full') {
            self.operate();
            if (forceReload) {
              data = self.config.getter((function(data) {
                self.initialized = true;
                return self.raw = data;
              }), self.params);
            }
          }
          if (self.config.type === 'partial') {
            return data = self.config.getter((function() {
              self.initialized = true;
              self.data.total = data.total;
              return self.raw = data.data;
            }), self.params);
          }
        }), true);
        self.operate = function() {
          var filtered, from, num, page, pages, prev, to, _i, _len, _results;
          if (!self.initialized) {
            return;
          }
          if (self.config.type === 'full') {
            filtered = self.config.do_filter.call(self, self.raw);
            self.data.total = filtered.length;
            self.data.pages = Math.ceil(filtered.length / self.params.limit);
            if (self.params.page > self.data.pages) {
              self.params.page = self.data.pages;
            }
            if (self.params.page < 1) {
              self.params.page = 1;
            }
            self.data.display = filtered.splice((self.params.page - 1) * self.params.limit, self.params.limit);
          }
          if (self.config.type === 'partial') {
            self.data.pages = Math.ceil(self.data.total / self.params.limit);
            if (self.params.page > self.data.pages) {
              self.params.page = self.data.pages;
            }
            if (self.params.page < 1) {
              self.params.page = 1;
            }
            self.data.display = self.raw;
          }
          if (self.data.total) {
            from = (self.params.page - 1) * self.params.limit + 1;
            to = self.params.page * self.params.limit;
            to = to < self.data.total ? to : self.data.total;
            self.data.first = from;
            self.data.last = to;
          } else {
            self.data.first = 0;
            self.data.last = 0;
          }
          self.pagination = [];
          pages = (function() {
            var _i, _ref, _results;
            _results = [];
            for (num = _i = 1, _ref = self.data.pages; 1 <= _ref ? _i <= _ref : _i >= _ref; num = 1 <= _ref ? ++_i : --_i) {
              _results.push(num);
            }
            return _results;
          })();
          prev = 0;
          _results = [];
          for (_i = 0, _len = pages.length; _i < _len; _i++) {
            page = pages[_i];
            if (page < 4 || page > self.data.pages - 4 || (page > self.params.page - 3 && page < self.params.page + 3)) {
              if (prev !== page - 1) {
                self.pagination.push(0);
              }
              self.pagination.push(page);
              _results.push(prev = page);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        self.setPage = function(page) {
          if (page > self.data.pages) {
            return;
          }
          if (page) {
            return self.params.page = page;
          }
        };
        self.setOrderby = function(orderby) {
          if (self.params.orderby === orderby) {
            return self.params.reverse = !self.params.reverse;
          } else {
            return self.params.orderby = orderby;
          }
        };
        self.headerClass = function(sorting) {
          if (self.params.orderby === sorting && self.params.reverse) {
            return self.config.sortingClasses.desc;
          }
          if (self.params.orderby === sorting && !self.params.reverse) {
            return self.config.sortingClasses.asc;
          }
          return self.config.sortingClasses.none;
        };
        self.reload = function() {
          return self.params.random = Math.random();
        };
        self.reload();
        return self;
      };
    }
  ]);

}).call(this);
